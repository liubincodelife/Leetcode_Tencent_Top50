# [Leetcode148.排序链表](<https://leetcode-cn.com/problems/sort-list/>)

- 方法分析

  根据题目要求，算法的时间复杂度为$O(nlogn)$，空间复杂度为$O(1)$，首先想到的是**归并排序和快速排序**。此题利用快速排序求解，但是在对数组进行归并排序时，其空间复杂度为$O(n)$，需要定义一个数组来保存整个排序数组的数据，但是实际上对链表的归并排序不需要这样做，空间复杂度为常数级的。

  **归并排序的三部曲：**

  - 利用快慢指针的方法找到链表的中间节点
  - 递归调用mergeSort将链表进行划分
  - 合并划分后的链表

  其中，寻找链表中间节点的步骤为：首先定义两个指针，快指针每次移动两步，慢指针一次移动一步，当快指针移动到链表末尾时，慢指针所在的位置就是中间位置，这样就可以将链表分成两部分。

  排序的原理：在对两个链表进行merge时，把两段链表的头节点进行比较，若左边链表的头节点小于右边节点，则继续对左边链表的后续节点和右边节点进行相同的比较过程，直至所有划分区域排序完毕。

- 复杂度分析

  - 时间复杂度

    使用了归并排序，时间复杂度为$O(nlogn)$。

  - 空间复杂度

    除去递归栈消耗的内存外，整个排序过程只需要使用几个节点指针，所以空间复杂度为$O(1)$。
