# [Leetcode61.旋转链表](<https://leetcode-cn.com/problems/rotate-list/>)

- 方法分析

  此题看起来需要将链表中的所有节点都向右移动$k$步，实则不然。首先需要遍历一遍链表计算出链表的长度，然后根据输入参数$k​$即可计算出新的头节点和尾节点的位置，然后只需要在新的尾节点处断开链表，并让新的头节点指向原来的头节点即为旋转后的矩阵。整个旋转过程如下图所示：

  ![61.png](assets/e3371c6b03e3c8d3758dcf0b35a45d0a6b39c111373cf7b5bde53e14b6271a04-61.png)

  $k$的取值有两种情况：

  - 当$k<length$时，$length-k$为新的头节点位置，$length-k-1$为新的尾节点位置
  - 当$k>=length$时，只需要考虑移动$k\%n$步即可

  综上：新链表的头节点位置为$length - k\%length$，新链表的尾节点位置为$length-k\%length-1$。

- 复杂度分析

  - 时间复杂度

    由于整个过程需要遍历一遍链表全部节点，所以时间复杂度为$O(n)$。

  - 空间复杂度

    整个过程只需要定义几个节点指针，所以空间复杂度为$O(1)$。
