# [Leetcode021.合并两个有序链表](<https://leetcode-cn.com/problems/merge-two-sorted-lists/>)

- 方法分析

  - 递归法

    当两个链表中其中一个为空时，直接返回非空链表为合并后的结果。否则，判断两个链表的头节点大小，取较小的节点与接下来元素的merge操作的递归结果合并。

  - 迭代法

    迭代法的实现需要引入“哨兵节点”，这样可以方便在合并之后直接返回链表头节点。

    首先定义一个哨兵节点`prehead`和临时节点`pNode`，临时节点初始化时指向哨兵节点。然后依次比较两个链表的节点元素大小，将较小的节点接到`pNode`节点后面，然后将`pNode`节点向后移一位，直至两个链表中有一个为空，然后将另一个非空链表直接接到`pNode`后面。这样就得到了合并后的链表，然后返回`prehead->next`即为链表的头节点指针。

- 复杂度分析

  - 时间复杂度

    两种方法的时间复杂度与合并后链表的长度呈线性关系，所以时间复杂度为$O(n+m)$。

  - 空间复杂度

    递归法需要遍历两个链表的所有元素，所以需要消耗$O(n+m)$的栈空间，而迭代法只需要使用两个节点指针，所以空间复杂度为$O(1)$。
