# Leetcode53.最大子序和

- 方法分析

  这道题目可利用**动态规划**或**分治**法来解决，这里用动态规划的方法来解决。

  定义两个变量：**max_sofar**和**max_end**分别存储最大的子序列和以及当前的序列和。

  - 对于max_end，每次计算累加和之后和当前位置元素进行比较，如果小于当前元素的值，则max_end=nums[i]。其中$i$是当前遍历到的数组元素偏移。否则一直累加。
  - 对于max_sofar，每次计算完max_end之后将max_end的最大值保存在max_sofar变量中，直到遍历结束，输出最大子序和。

- 复杂度分析

  - 时间复杂度

    由于整个过程需要遍历一遍数组全部元素，所以时间复杂度为$O(n)$。

  - 空间复杂度

    整个过程除了传入的数组$nums$外没有分配额外的内存，所以空间复杂度为$O(1)$。
